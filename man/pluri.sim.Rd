% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pluri.sim.r
\name{pluri.sim}
\alias{pluri.sim}
\title{Plurigaussian Simulation}
\usage{
pluri.sim(
  simu_grid,
  conditioning_data,
  truncation_rule,
  variog_model,
  neigb_par,
  simu_par
)
}
\arguments{
\item{simu_grid}{A list of arguments to define the grid parameters. Use list(x0, y0, z0, nx, ny, nz, dx, dy, dz),
where:
  - x0, y0, z0: Single values indicating the minimum grid coordinates along the East-West, North-South, and vertical directions, respectively.
  - nx, ny, nz: Single values indicating the number of grid nodes along the East-West, North-South, and vertical directions, respectively.
  - dx, dy, dz: Single values indicating the grid mesh sizes along the East-West, North-South, and vertical directions, respectively.}

\item{conditioning_data}{A matrix of conditioning data (categorical and continuous) with dimensions (number of data x 4). The columns are as follows:
  - Columns 1-3: Coordinates (x, y, z) of the conditioning data.
  - Column 4: Conditioning values of the categorical data (numerical codes of facies).
When no conditional data is imported, leave this argument empty to build an unconditional model.
When two-dimensional simulation is required, fill the third column with zeros.}

\item{truncation_rule}{A list of arguments to determine the truncation rule of Plurigaussian. Use list(nfield, nthres, thresholds, flag),
where:
  - nfield: Number of GRFs used for the truncation rule.
  - nthres: A vector with the number of thresholds for each GRF (1 x nfield).
  - thresholds: A vector of the thresholds for all GRFs (1 x sum(nthres)).
  - flag: A vector with category numbers codifying the truncation rule.
  - vpc_matrix: A matrix containing the proportions of facies for each z-level. It can be the matrix of vertical proportion curves obtained from the vpc function. Each row name in the matrix should define the corresponding z-level. Currently, the input is limited to a matrix that represents the vertical proportions across the entire examined area. If no available data is provided, leave it as NULL.}

\item{variog_model}{A list of arguments to define the nested variogram theoretical models. Use list(model, cc, b, nugget),
where:
  - model: A matrix containing the covariance model for the GRFs (nested structures x 7 matrix). Each row corresponds to a nested structure and is codified as: type, scale factors, angles. Use the codes of the available types of variogram models (see details). There are three scale factors (along the rotated NS, EW, and vertical axes) and three angles to define the coordinate rotation (azimuth, dip, and plunge). See Deutsch & Journel (1997, p. 25) for more information.
  - cc: A matrix indicating the sills of nested structures (nested structures x (1 + nfield)^2).
  - b: A column vector with the additional parameters required for specific covariance types (nested structures x 1). See details for specific covariance types and their corresponding requirements.
  - nugget: A row vector with the nugget effect variance-covariance matrix of size (1 + nfield)^2.}

\item{neigb_par}{A list of arguments to define the moving neighborhood to condition the data. Use list(radius, angles, octant, ndata),
where:
  - radius: A row vector with the maximum search radii along the rotated NS, EW, and vertical axes (1 x 3) for conditioning data.
  - angles: A row vector with the angles for anisotropic search (1 x 3), based on Deutsch and Journel (1997, p. 27).
  - octant: A value of 1 or 0, specifying if the neighborhood should be divided into octants (1) or not (0).
  - ndata: A single value indicating the number of conditioning data per octant or in total.}

\item{simu_par}{A list of arguments to define the simulation parameters. Use list(nlines, nrealiz, seed, nnodes, itGibbs),
where:
  - nlines: A single value indicating the number of lines to use for simulating the nested structures by turning bands.
  - nrealiz: A single value indicating the number of realizations to produce.
  - seed: The seed number for generating random values.
  - nnodes: The number of nodes per line segment. 
  - itGibbs: The number of iterations in Gibbs' sampling.}
}
\value{
A list of the simulated coordinates and the respective simulated categorical and continuous values.
  - coord: A matrix containing the center coordinates of gridded blocks (number of blocks x 3).
  - categoricalVar: A matrix containing the simulated values of the categorical variable (number of blocks x nrealiz).
    Each column represents a realization of the categorical variable.
}
\description{
Perform conditional or unconditional Plurigaussian simulation the turning bands method
The function simulates categorical variables (facies) using currently non-correlated GRFs. The GRFs are assumed to be jointly Gaussian,
with zero mean and unit variance. The GRFs are spatially independent by setting their cross-covariance to zero.
Multiple realizations of the simulated facies can be produced on a regular grid.
}
\details{
Available types of variogram model:
1: spherical
2: exponential (beware that range = 3*scale factor)
3: gamma (parameter b > 0)
4: stable (parameter b between 0 and 2)
5: cubic
6: Gaussian
7: cardinal sine
8: Bessel J (parameter b > 0)
9: Bessel K (parameter b > 0)
10: generalized Cauchy (parameter b)
11: exponential sine
}
\examples{
simu_grid <- list(x0 = -15050, y0 = 17200, z0 = 445,
nx = 31, ny = 27, nz = 25,
dx = 100, dy = 100, dz = 10)
SFM_Facies <- as.numeric(replace.values(SFM_data[, 4], c("AL", "CO", "HD", "MG", "SG"), 
c(1, 2, 3, 4, 5)))
conditioning_data <- data.matrix(as.data.frame(cbind(as.numeric(SFM_data$x[1:100]),
as.numeric(SFM_data$y[1:100]),
as.numeric(SFM_data$z[1:100]),
SFM_Facies[1:100])))
colnames(conditioning_data) <- c("x", "y", "z", "Facies_code")
truncation_rule <- list(nfield = 2, nthres = c(2, 2),
thresholds = c(-0.5769, 1.0762, -0.4895, 0.6592),
flag = c(2, 1, 3, 2, 1, 5, 2, 4, 4), vpc_matrix = NULL)
nst_str <- 2
sills_matrix <- matrix(c(0.6113, 0, 0, 0.6113, 0.6768, 0.2239, 0.2239, 0.6768), nst_str, 4, 
byrow = TRUE)
variogram_models <- matrix(c(1, 400, 400, 140, 0, 0, 0, 2, 300, 300, 90, 0, 0, 0), nst_str, 7, 
byrow = TRUE)
variog_model <- list(model = variogram_models, cc = sills_matrix,
b = matrix(0, nrow = nst_str, ncol = 1), nugget = c(0.3887, 0, 0, 0.0992))
neigb_par <- list(radius = c(400, 400, 20), angles = c(0, 0, 0), octant = 1, ndata = 100)
simu_par <- list(nlines = 1000, nrealiz = 2, seed = 800, nnodes = 20000, itGibbs = 100)
results <- pluri.sim(simu_grid, conditioning_data, truncation_rule, variog_model, neigb_par, 
simu_par)

}
