% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pluri.sim.r
\name{pluri.sim}
\alias{pluri.sim}
\title{Plurigaussian Simulation}
\usage{
pluri.sim(
  simu_grid,
  conditioning_data,
  truncation_rule,
  variog_model,
  neigb_par,
  simu_par
)
}
\arguments{
\item{simu_grid}{A list of arguments to define the grid parameters. Use list(x0,y0,z0,nx,ny,nz,dx,dy,dz),
where: x0, y0, z0 are    single values indicating the minimum grid coordinates along EW, NS and vertical directions,
nx, ny, nz    are single values indicating the number of grid nodes along east, north and vertical directions,
dx, dy, dz    are single values indicating the grid meshes along EW, NS and vertical directions}

\item{conditioning_data}{A matrix of conditioning data (number of data x 4). The first columns contain the coordinates (x,y,z) of the conditioning data; the fourth column contains the conditioning values of the categorical data (numerical codes of facies).
When no conditional data are imported, the argument remains empty, so an unconditional model is built.}

\item{truncation_rule}{A list of arguments to determine the truncation rule of Plurigaussian. Use list(nfield,nthres,thresholds,flag).
where: nfield is the number of GRFs used for the truncation rule,
nthres is a vector with the number of thresholds for each GRF (1  x nfield),
thresholds is a vector of the thresholds for all GRFs (1 x sum(nthres)),
flag is a vector with category numbers codifying the truncation rule}

\item{variog_model}{A list of arguments to define the nested variogram theoretical models. Use list(model,cc,b,nugget)
where: model is a matrix containing the covariance model for the GRFs (nested structures x 7 matrix). Each row corresponds to a nested structure and is codified as: type, scale factors, angles. Use the codes of the availiable types of variogram model (see details). There are three scale factors (along the rotated NS, EW and vertical axes) and three angles to define the coordinates rotation (azimuth, dip and plunge), see Deutsch & Journel (1997, p.25).
cc is a matrix indicating the sills of nested structures (nested structures x nfield^2),
b is column vector with the additional parameters required for specific covariance types  (nested structures x 1), Also, see details.
nugget is a row vector with nugget effect variance-covariance matrix with size of nfield^2.}

\item{neigb_par}{A list of arguments to define the moving neighborhood to condition the data. Use list list(radius,angles,octant,ndata) 
where: radius is a row vector row vector with the maximum search radii along the rotated NS, EW and vertical axes (1 x 3) for conditioning data,
angles is a row vector with the angles for anisotropic search (1 x 3), based on Deutsch and Journel (1997, p. 27),
octant takes values 1 or 0, specifying if the neighborhood should be divided into octants (1) or not (0),
ndata is a single value with the number of conditioning data per octant or in total}

\item{simu_par}{A list of arguments to define the simulation parameters. Use list(nlines,nrealiz,seed,nnodes,itGibbs),
where: nlines is a single value indicating the number of lines to use for simulating the nested structures by turning bands,
nrealiz is a single value indicating the number of realizations to produce,
seed is the seed number for generating random values}
}
\value{
A list of the simulated coordinates and the respective categorical values.
coord contains the center of gridded blocks (number of blocks x 3),
categoricalVar contains the simulated values of categorical variable (number of blocks x nrealiz). Each column is a realization of categorical variable.
}
\description{
Plurigaussian simulation of GRFs using the turning bands method
The function simulates categorical variables (facies) using spatially correlated GRFs. The GRFs  are stationary and jointly Gaussian,
with zero means and unit variances. The GRFs can also be taken as spatially independent by setting their cross-covariance to zero.
Multiple realizations of the simulated facies can be produced in a regular grid.
}
\details{
The output of the function is a list of two matrices: $coord contains the center of blocks in the grid (number of blocks x 3) and $categoricalVar contains the simulated values of categorical variable (number of blocks x nrealiz - each column is a realization of the categorical variable).
Available types of variogram model:
1: spherical
2: exponential (beware that range = 3*scale factor)
3: gamma (parameter b > 0)
4: stable (parameter b between 0 and 2)
5: cubic
6: Gaussian
7: cardinal sine
8: Bessel J (parameter b > 0)
9: Bessel K (parameter b > 0)
10: generalized Cauchy (parameter b)
11: exponential sine
Regarding the conditioning data, in lower than three dimensions use also three columns of the coordinates (use constant values in y or/and z).
}
\examples{
simu_grid <- list(x0 = -15050, y0 = 17200, z0 = 445,
nx = 31, ny = 27, nz = 25,
dx = 100, dy = 100, dz = 10)
SFM_Facies <- as.numeric(replace.values(SFM_data[ ,4], c("AL","CO","HD","MG","SG"), c(1,2,3,4,5)))
conditioning_data <- data.matrix(as.data.frame(cbind(as.numeric(SFM_data$x[1:100]),
as.numeric(SFM_data$y[1:100]), as.numeric(SFM_data$z[1:100]), SFM_Facies[1:100])))
colnames(conditioning_data)<-c("x","y","z","Facies_code")
truncation_rule <- list(nfield = 2 , nthres = c(2,2),
thresholds = c(-0.5769, 1.0762, -0.4895, 0.6592), flag = c(2,1,3,2,1,5,2,4,4))
nst_str <- 2
sills_matrix <- matrix(c(0.6113,0,0,0.6113,0.6768,0.2239,0.2239,0.6768),nst_str,4,byrow = TRUE)
variogram_models <- matrix(c(1,400,400,140,0,0,0,2,300/3,300/3,90/3,0,0,0),nst_str,7,byrow = TRUE)
variog_model <- list(model = variogram_models, cc = sills_matrix,
b = matrix(0,nrow=nst_str,ncol=1), nugget = c(0.3887,0,0,0.0992))
neigb_par <- list(radius = c(400,400,20),  angles = c(0,0,0), octant = 1, ndata = 100)
simu_par <- list(nlines = 1000, nrealiz = 2, seed = 800, nnodes = 20000, itGibbs = 100)
results <- pluri.sim(simu_grid,conditioning_data,truncation_rule,variog_model,neigb_par,simu_par)

}
